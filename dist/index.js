import{EventEmitter as B}from"node:events";import I from"node:net";import L from"node:tls";var a=class extends Error{code;name;constructor(e,t,r){super(e),typeof t=="string"&&(this.code=t),typeof r=="string"&&(this.name=r)}};var i=class{static toBuffer({payload:e,id:t,command:r}){if(e===void 0)throw new TypeError("The payload must not be undefined!");let s=JSON.stringify(e),n=Buffer.allocUnsafe(s.length+3);return n.writeUInt16LE(t,0),n.writeUInt8(r,2),n.write(s,3),n}static parse(e){if(e.length<3)throw new TypeError(`Token too short! Expected at least 3 bytes, got ${e.length}!`);let t=e.readUInt16LE(0),r=e.readUInt8(2),s=JSON.parse(e.toString("utf8",3));return{id:t,command:r,payload:s}}};import{EventEmitter as S}from"node:events";var p=Buffer.from(`
`)[0],u=Buffer.from("\\")[0],N=Buffer.from("n")[0],m=class{static escape(e){let t=[];for(let r of e)switch(r){case u:t.push(u),t.push(u);break;case p:t.push(u),t.push(N);break;default:t.push(r);break}return t.push(p),Buffer.from(t)}static unescape(e){let t=[];for(let r=0;r<e.length-1;r++){let s=e[r],n=e[r+1];if(s===u)switch(n){case u:t.push(u),r+=1;break;case N:t.push(p),r+=1;break;default:throw new Error("Unescaped backslash detected!")}else t.push(s)}return Buffer.from(t)}};var T=Buffer.from(`\\
`),c=class extends S{duplex;buffer=Buffer.allocUnsafe(0);constructor(e){super(),this.duplex=e,this.applyListeners()}applyListeners(){this.duplex.on("data",e=>{this.buffer=Buffer.concat([this.buffer,e]),this.parse()}),this.duplex.on("close",()=>{this.emit("close")})}parse(){for(;this.buffer.length>0;){let e=this.buffer.indexOf(p);if(e===-1)break;let t=this.buffer.subarray(0,e+1);t.equals(T)?this.emit("remoteClose"):this.emit("token",m.unescape(t)),this.buffer=this.buffer.subarray(e+1)}}get isDead(){return!this.duplex.writable||!this.duplex.readable}send(e){return this.isDead?!1:(this.duplex.write(m.escape(e)),!0)}close(){return this.isDead?!1:(this.duplex.end(),!0)}remoteClose(){return this.isDead?!1:(this.duplex.write(T),!0)}};var h=class{static serialize(e){let{message:t,name:r,stack:s}=e;return{message:t,name:r,stack:s,...e}}static deserialize(e){let t=this.getFactory(e),r=new t(e.message);return Object.assign(r,e),r}static getFactory(e){let t=e.name;return t.endsWith("Error")&&global[t]?global[t]:Error}};var f=(s=>(s[s.ONLINE=3]="ONLINE",s[s.CONNECTING=2]="CONNECTING",s[s.CLOSED=1]="CLOSED",s[s.OFFLINE=0]="OFFLINE",s))(f||{});var d=class{ids=[];index=0;maxIndex;constructor(e=2**16-1){this.maxIndex=e}release(e){if(e<0||e>this.maxIndex)throw new TypeError(`ID must be between 0 and ${this.maxIndex}. Got ${e}.`);this.ids[e]=!1}reserve(){let e=this.index;for(;;){let t=this.index;if(!this.ids[t])return this.ids[t]=!0,t;if(this.index>=this.maxIndex?this.index=0:this.index++,this.index===e)throw new Error("All IDs are reserved. Make sure to release IDs when they are no longer used.")}}};var v=class{value;expiration;constructor(e,t){this.value=e,this.expiration=Date.now()+t}get expiresIn(){return this.expiration-Date.now()}get isExpired(){return Date.now()>this.expiration}},E=class{items=[];add(e,t){this.items.push(new v(e,t))}get isEmpty(){let e=this.items.length;for(;e--;)if(this.items[e].isExpired)this.items.splice(e,1);else return!1;return!0}pop(){for(;this.items.length;){let e=this.items.shift();if(!e.isExpired)return e}return null}};var b=class extends B{options;socket;connection=null;hadError;status;constructor(e){super(),this.options=e,this.connect()}connect(){return this.status>=1?!1:(this.hadError=!1,this.status=2,this.options.secure?this.socket=L.connect(this.options):this.socket=I.connect(this.options),this.connection=null,this.applyListeners(),!0)}close(){return this.status<=1?!1:(this.status=1,this.socket.end(),this.connection=null,!0)}send(e){return this.connection?this.connection.send(e):!1}applyListeners(){this.socket.on("error",e=>{this.hadError=!0,this.emit("error",e)}),this.socket.on("close",()=>{this.status=0,this.emit("close",this.hadError)}),this.socket.on("secureConnect",()=>{this.updateConnection(),this.status=3,this.emit("connect")}),this.socket.on("connect",()=>{this.updateConnection(),this.status=3,this.emit("connect")})}updateConnection(){let e=new c(this.socket);e.on("token",t=>{this.emit("token",t,e)}),e.on("remoteClose",()=>{this.emit("remoteClose",e)}),this.connection=e}},y=class extends b{queue=new E;constructor(e){super(e),this.applyEvents()}sendBuffer(e,t){this.send(e)||this.queue.add(e,t)}applyEvents(){this.on("connect",()=>{for(;!this.queue.isEmpty;){let e=this.queue.pop();this.sendBuffer(e.value,e.expiresIn)}})}close(){return super.close()}},C=class extends y{ids=new d(65535);callbacks={};constructor(e){super(e),this.init()}init(){this.on("token",e=>{try{let t=i.parse(e);if(this.callbacks[t.id])if(t.command===255){let r=h.deserialize(t.payload);this.callbacks[t.id](r,void 0)}else this.callbacks[t.id](null,t.payload)}catch(t){this.emit("error",t)}})}async command(e,t,r=3e4,s=void 0){if(e===255)throw new a("Command 255 is reserved.","ERESERVED","CommandError");let n=this.ids.reserve(),l=i.toBuffer({id:n,command:e,payload:t});this.sendBuffer(l,r),(r===0||r===null||r===1/0)&&(r=6e4);let O=this.createResponsePromise(n),g=this.createTimeoutPromise(n,r);if(typeof s=="function")try{let x=await Promise.race([O,g]);try{s(x,void 0)}catch{}}catch(x){s(void 0,x)}else return Promise.race([O,g])}createTimeoutPromise(e,t){return new Promise((r,s)=>{setTimeout(()=>{this.ids.release(e),delete this.callbacks[e],s(new a("Command timed out.","ETIMEOUT","CommandError"))},t)})}createResponsePromise(e){return new Promise((t,r)=>{this.callbacks[e]=(s,n)=>{this.ids.release(e),delete this.callbacks[e],s?r(s):t(n)}})}close(){return super.close()}};import{EventEmitter as D}from"node:events";import F from"node:net";import z from"node:tls";var k=class extends D{connections=[];options;server;hadError;status;constructor(e){super(),this.options=e,this.options.secure?this.server=z.createServer(this.options,function(t){t.on("error",r=>{this.emit("clientError",r)})}):this.server=F.createServer(this.options,function(t){t.on("error",r=>{this.emit("clientError",r)})}),this.applyListeners(),this.connect()}connect(){return this.status>=2?!1:(this.hadError=!1,this.status=2,this.server.listen(this.options),!0)}close(){if(!this.server.listening)return!1;this.status=1,this.server.close();for(let e of this.connections)e.remoteClose();return!0}applyListeners(){this.server.on("listening",()=>{this.status=3,this.emit("listening")}),this.server.on("tlsClientError",e=>{this.emit("clientError",e)}),this.server.on("clientError",e=>{this.emit("clientError",e)}),this.server.on("error",e=>{this.hadError=!0,this.emit("error",e),this.server.close()}),this.server.on("close",()=>{this.status=0,this.emit("close",this.hadError)}),this.server.on("secureConnection",e=>{let t=new c(e);this.connections.push(t),t.once("close",()=>{let r=this.connections.indexOf(t);r!==-1&&this.connections.splice(r,1)}),t.on("token",r=>{this.emit("token",r,t)})}),this.server.on("connection",e=>{if(this.options.secure)return;let t=new c(e);this.connections.push(t),t.once("close",()=>{let r=this.connections.indexOf(t);r!==-1&&this.connections.splice(r,1)}),t.on("token",r=>{this.emit("token",r,t)})})}},w=class extends k{commands={};constructor(e){super(e),this.init()}init(){this.on("token",async(e,t)=>{try{let{id:r,command:s,payload:n}=i.parse(e);this.runCommand(r,s,n,t)}catch(r){this.emit("error",r)}})}command(e,t){this.commands[e]=t}async runCommand(e,t,r,s){try{if(!this.commands[t])throw new a(`Command (${t}) not found.`,"ENOTFOUND","CommandError");let n=await this.commands[t](r,s),l=n===void 0?"OK":n;s.send(i.toBuffer({command:t,id:e,payload:l}))}catch(n){let l=h.serialize(n);s.send(i.toBuffer({command:255,id:e,payload:l}))}}};export{a as CodeError,C as CommandClient,w as CommandServer,c as Connection,f as Status};
